---
title: "RPGSimulator"
subtitle: "Développement d'un simulateur de combat RPG en Julia"
author: 
  - "Maxime, Jed, Hussin et Simon"
format: 
  html:
    toc: true #Pour activer la table des matières
    toc-depth: 3
    toc-title: "Sommaire" #toc concerne la table des matières
    number-sections: true
    code-fold: true
    code-summary: "Voir le code"
    theme: cosmo
---

# Introduction

## Contexte du Projet

Ce rapport présente le développement complet de notre projet : **RPGSimulator**, un simulateur de combat RPG tour par tour entièrement réalisé en Julia. Notre équipe n'avait aucune connaissance préalable du langage Julia au démarrage. L'apprentissage s'est effectué de manière autonome en s'appuyant principalement sur le cours CQLS ([https://cqls.dyndoc.fr/julia]) et avec l'aide de M.Drouilhet, notre enseignant pour ce projet.

L'objectif était double : maîtriser les fondamentaux et les notions plus avancées de Julia (notamment le **multiple dispatch**) tout en construisant un projet fonctionnel, structuré et extensible. Le résultat est un moteur de combat intégrant un système de rôles, de compétences spécialisées, d'effets de statut, de simulations et de visualisations interactives.


## Objectifs Pédagogiques et Techniques

**Apprentissage de Julia** : Comprendre la philosophie du langage, sa gestion des types, le multiple dispatch, les performances et l'écosystème de packages. Progresser depuis une compréhension basique jusqu'à une utilisation avancée incluant la composition de types, les tests unitaires et l'optimisation.

**Développement structuré** : Organiser un projet complexe en modules distincts, séparer les responsabilités, gérer les dépendances et maintenir une base de code claire et extensible.

**Exploitation du multiple dispatch** : Utiliser ce paradigme comme pilier pour créer un système flexible où l'ajout de nouveaux comportements ne nécessite pas de modification du code existant.

**Validation et qualité** : Mettre en place des tests unitaires systématiques garantissant la fiabilité du code et la reproductibilité des résultats.

**Simulation et analyse** : Implémenter des simulations pour évaluer l'équilibrage du jeu et analyser les stratégies gagnantes.

**Visualisation** : Créer des interfaces interactives (RShiny) et des graphiques dynamiques (Bonito) pour représenter visuellement l'évolution des combats (par exemple l'évolution des points de vie au fil des tours) et faciliter l'analyse des résultats.



# rchitecture et Structure du Projet

## Organisation Modulaire

Le projet est organisé en plusieurs fichiers spécialisés, chacun ayant une responsabilité clairement définie. Cette modularité facilite la maintenance, l'extension et la compréhension du code. Nous avons aussi un rapport et un README.

```
RPGSimulator/
|---- src/
|     |-- RPGSimulator.jl # Module principal (exports, includes)
|     |-- roles.jl # Définition des personnages et Stats
|     |-- effets.jl # Système d'effets de statut
|     |-- attaques.jl # Mécanique d'attaque et calcul de dégâts
|     |-- skills.jl # Compétences spécialisées par rôle
|     |-- combat.jl # Moteur de combat tour par tour
|     |-- simulation.jl # Simulations multiples et statistiques
|---- test/
|     |-- runtests.jl # Tests unitaires
|---- examples/
|     |-- tests.jl #Fichier test du code
|---- Bonito/
|     |-- Bonito.md # Visualisations Bonito
|---- RShiny/
|     |-- App.R #Visualisation RShiny
```


## Hiérarchie des Types

Julia utilise un système de types avec hiérarchie. Nous avons défini trois hiérarchies principales pour structurer notre jeu.

**Hiérarchie Role** : Type abstrait `Role` avec quatre rôles concrets (`Archer`, `Mage`, `Chevalier`, `Gobelin`). Chaque rôle possède un nom, des statistiques (`Stats`) et une liste d'effets actifs (`Vector{Any}`).

**Hiérarchie StatusEffect** : Type abstrait `StatusEffect` regroupant cinq effets distincts : `Poison` (dégâts par tour), `Bleed` (saignement), `Shield` (protection), `Stun` (perte de tour), `Regen` (régénération).

**Hiérarchie Skill** : Type abstrait `Skill` avec deux compétences implémentées : `Fireball` (Mage, dégâts magiques élevés) et `PowerStrike` (Chevalier, attaque puissante).

Cette architecture permet l'extension facile du jeu : ajouter un nouveau rôle, effet ou compétence ne nécessite que la définition d'une nouvelle structure et éventuellement de méthodes spécialisées, sans toucher au code existant.


## Structure des Données

### Stats (Statistiques de Base)

```julia
mutable struct Stats
    PV::Int          # Points de Vie
    PM::Int          # Points de Magie
    ATK::Int         # Attaque
    VITESSE::Int     # Détermine l'ordre d'action
    DEFENSE::Int     # Réduit les dégâts reçus
end
```

Les Stats sont mutables car elles changent pendant le combat (PV diminuent, PM se consomment). Un constructeur par défaut facilite la création de personnages en leur attribuant automatiquement des valeurs standard. Cela permet également d'avoir la possibilité de faire des simulations sans personnaliser les stats de combat.

### Rôles et Différenciation

Chaque rôle possède des caractéristiques distinctes créant des profils de jeu différents :

- **Archer** (Robin) : PV=90, PM=30, ATK=15, VITESSE=20, DEFENSE=8. Rapide et précis, idéal pour frapper en premier.
- **Mage** (Gandalf) : PV=70, PM=100, ATK=25, VITESSE=12, DEFENSE=6. Fragile mais dégâts magiques dévastateurs.
- **Chevalier** (Arthur) : PV=120, PM=20, ATK=18, VITESSE=10, DEFENSE=20. Tank résistant avec attaques puissantes.
- **Gobelin** (Gabimarou) : PV=60, PM=10, ATK=12, VITESSE=14, DEFENSE=5. Faible mais agile, bon pour les tests.



# Mécaniques de Combat

## Calcul des Dégâts : Approche Probabiliste

Le système de combat repose sur un modèle probabiliste réaliste plutôt que sur des valeurs fixes. La fonction `compute_damage` utilise une distribution normale pour générer de l'aléatoire contrôlé.

```julia
function compute_damage(base_atk::Int, def::Int; 
                       sd_frac=0.12, 
                       crit_chance=0.10, 
                       crit_mult=1.6)
    # Écart-type proportionnel à l'attaque
    sd = max(1.0, abs(base_atk) * sd_frac)
    
    # Tirage selon loi normale
    d = rand(Normal(base_atk, sd))
    
    # Application de la défense
    raw = max(Int(round(d)) - def, 0)
    
    # Gestion des coups critiques
    is_crit = (rand() < crit_chance) && raw > 0
    raw = is_crit ? Int(round(raw * crit_mult)) : raw
    
    return raw, is_crit
end
```

**Paramètres ajustables** : L'écart-type (`sd_frac`) contrôle la variance des dégâts, le taux de critique (`crit_chance`) et le multiplicateur (`crit_mult`) permettent de différencier les attaques. Par exemple, `Fireball` utilise `sd_frac=0.05` (peu de variance), `crit_chance=0.22` (élevé) et `crit_mult=2.2` (dégâts explosifs).

**Défense** : Fonctionne en soustraction pure. Une défense de 20 réduit tous les dégâts entrants de 20 points. Certaines compétences magiques (comme `Fireball`) réduisent l'efficacité de la défense (×0.7) pour simuler la pénétration magique.


## Multiple Dispatch : Cœur du Système

Le multiple dispatch est la caractéristique distinctive de Julia qui permet de définir plusieurs versions d'une même fonction en fonction des types de tous ses arguments. Contrairement à la programmation orientée objet classique où la méthode dépend uniquement du type de l'objet appelant, 
Julia sélectionne la méthode la plus spécifique selon les types de tous les paramètres.

### Attaques Standard

```julia
# Signature générique : fonctionne pour n'importe quel Role
function attaquer(att::Role, def::Role; shield::Int=0, 
                 dmg_mat=Dict(), skill_usage=Dict())
    dmg, crit = compute_damage(att.stats.ATK, 
                               def.stats.DEFENSE - shield)
    def.stats.PV = max(def.stats.PV - dmg, 0)
    println("$(att.nom) attaque $(def.nom) et inflige $dmg dégâts" 
            * (crit ? " (CRIT!)" : ""))
    
    # Enregistrement des dégâts par matchup
    acls, dcls = string(typeof(att)), string(typeof(def))
    dmg_mat[(acls,dcls)] = get(dmg_mat,(acls,dcls),0) + dmg
    
    return dmg
end
```

Cette fonction unique gère toutes les attaques basiques. Julia compile automatiquement une version optimisée pour chaque combinaison de types rencontrée (Archer→Gobelin, Mage→Chevalier, etc.).

### Compétences Spécialisées

Le véritable pouvoir du multiple dispatch apparaît avec les compétences.

```julia
# Méthode par défaut (fallback)
function use_skill(att::Role, skl::Skill, target::Role; kwargs...)
    println("$(att.nom) utilise une compétence non spécifiée.")
    return 0
end

# Spécialisation : Mage lance Fireball
function use_skill(att::Mage, skl::Fireball, def::Role; 
                  dmg_mat=Dict(), skill_usage=Dict())
    # Vérification des PM
    if att.stats.PM < skl.cost_pm
        println("$(att.nom) n'a pas assez de PM pour Fireball.")
        return 0
    end
    
    att.stats.PM -= skl.cost_pm
    effective_def = Int(round(def.stats.DEFENSE * 0.7))
    base_atk = skl.power + Int(round(att.stats.ATK * 0.5))
    
    dmg, crit = compute_damage(base_atk, effective_def,
                               sd_frac=0.05, 
                               crit_chance=0.22, 
                               crit_mult=2.2)
    
    def.stats.PV = max(def.stats.PV - dmg, 0)
    println("$(att.nom) lance Fireball sur $(def.nom) => $dmg dégâts" 
            * (crit ? " (CRIT!)" : ""))
    
    skill_usage[string(typeof(skl))] = 
        get(skill_usage, string(typeof(skl)), 0) + 1
    
    return dmg
end

# Spécialisation : Chevalier utilise PowerStrike
function use_skill(att::Chevalier, skl::PowerStrike, def::Role; 
                  dmg_mat=Dict(), skill_usage=Dict())
    if att.stats.PM < skl.cost_pm
        println("$(att.nom) n'a pas assez de PM pour PowerStrike.")
        return 0
    end
    
    att.stats.PM -= skl.cost_pm
    base_atk = skl.power + Int(round(att.stats.ATK * 0.7))
    
    dmg, crit = compute_damage(base_atk, def.stats.DEFENSE,
                               sd_frac=0.03, 
                               crit_chance=0.18, 
                               crit_mult=1.8)
    
    def.stats.PV = max(def.stats.PV - dmg, 0)
    println("$(att.nom) utilise PowerStrike sur $(def.nom) => $dmg dégâts" 
            * (crit ? " (CRIT!)" : ""))
    
    acls = string(typeof(att)); dcls = string(typeof(def))
    dmg_mat[(acls,dcls)] = get(dmg_mat,(acls,dcls),0) + dmg
    skill_usage[string(typeof(skl))] = 
        get(skill_usage, string(typeof(skl)), 0) + 1
    
    return dmg
end
```

**Avantages** : Ajouter un nouveau rôle (ex: `Voleur`) avec une nouvelle compétence (ex: `Backstab`) ne nécessite que d'ajouter une nouvelle fonction `use_skill(att::Voleur, skl::Backstab, def::Role)`. Le code existant n'est jamais modifié, garantissant la stabilité et l'extensibilité.

## Système d'Effets de Statut

Les effets de statut ajoutent un point stratégique au combat. Chaque effet possède une durée (`remaining`) qui décrémente à chaque tour jusqu'à expiration.

### Types d'Effets Implémentés

**Poison** : Inflige `dmg_per_turn` points de dégâts à chaque tour. Exemple : `Poison(3, 8)` inflige 8 dégâts pendant 3 tours.

**Bleed** : Similaire au poison, représente un saignement continu. La séparation permet des mécaniques différentes (résistances, immunités).

**Shield** : Réduit les dégâts entrants de `flat_block` points à chaque tour. Exemple : `Shield(2, 15)` bloque 15 dégâts pendant 2 tours.

**Stun** : Empêche le personnage d'agir pendant `remaining` tours. Puissant effet de contrôle l'adversaire se retrouve étourdi.

**Regen** : Restaure `heal_per_turn` PV à chaque tour. Exemple : `Regen(3, 10)` soigne 10 PV pendant 3 tours.

### Application et Gestion

```julia
function apply_effects_round!(c::Role)
    new_effects = Any[]
    total_shield = 0
    total_poison = 0
    total_bleed = 0
    regen_amount = 0
    stunned = false
    
    # Parcours et application de chaque effet
    for e in c.effects
        if e isa Poison
            total_poison += e.dmg_per_turn
            e.remaining -= 1
        elseif e isa Shield
            total_shield += e.flat_block
            e.remaining -= 1
        elseif e isa Bleed
            total_bleed += e.dmg_per_turn
            e.remaining -= 1
        elseif e isa Stun
            stunned = true
            e.remaining -= 1
        elseif e isa Regen
            regen_amount += e.heal_per_turn
            e.remaining -= 1
        end
        
        # Conserver les effets actifs
        if e.remaining > 0
            push!(new_effects, e)
        end
    end
    
    c.effects = new_effects
    
    # Application des soins et dégâts
    if regen_amount > 0
        c.stats.PV += regen_amount
        println("$(c.nom) regenère $regen_amount PV.")
    end
    
    total_damage = total_poison + total_bleed
    if total_damage > 0
        c.stats.PV = max(c.stats.PV - total_damage, 0)
        println("$(c.nom) subit $total_damage dégâts (poison/bleed).")
    end
    
    return (total_shield, stunned, regen_amount, total_damage)
end
```

**Composition d'effets** : Un personnage peut avoir plusieurs effets simultanés qui se cumulent. Par exemple, `Poison(2,5) + Bleed(2,3) + Regen(2,10)` produit un bilan net de -8+10 = +2 PV par tour. Le joueur qui reçoit ces effets va donc regagner 2 points de vie par tour malgré le poison et le saignement.

## Moteur de Combat Tour par Tour

Le moteur de combat orchestre l'ensemble des mécaniques dans une boucle structurée avec logging détaillé.

### Déroulement d'un Tour

1. **Application des effets de statut** : Calcul de shield, stun, regen et dégâts pour les deux combattants.
2. **Détermination de l'ordre** : Le personnage avec la plus haute vitesse agit en premier.
3. **Actions réalisées** : Chaque combattant exécute son action (attaque ou compétence) sauf s'il est étourdi.
4. **Choix d'action** : Fonction `choose_action` détermine le comportement (attaque normale vs compétence).
5. **Logging** : Enregistrement de toutes les actions dans un tableau de logs (`AttackLog`).
6. **Vérification de fin** : Combat terminé si un combattant atteint 0 PV ou si `max_rounds` est atteint.

### Choix d'Actions Intelligents

```julia
# Comportement par défaut : attaque normale
choose_action(actor::Role, defender::Role) = (:attack, nothing)

# Mage : priorise Fireball si PM suffisants
choose_action(actor::Mage, defender::Role) = 
    actor.stats.PM ≥ 10 ? (:skill, Fireball(10, 30)) : (:attack, nothing)

# Chevalier : 20% de chance d'utiliser PowerStrike
choose_action(actor::Chevalier, defender::Role) = 
    (actor.stats.PM ≥ 8 && rand() < 0.2) ? 
        (:skill, PowerStrike(8, 20)) : (:attack, nothing)
```

Cette séparation permet de définir facilement un comportement différent pour chaque rôle, sans toucher au moteur de combat.

### Logging des Combats

```julia
struct AttackLog
    round::Int
    actor::String
    action::String
    target::String
    damage::Int
    actor_PV::Int
    target_PV::Int
end
```

Chaque action génère un log permettant l'analyse post-combat. Ces logs sont exportables pour un traitement externe (RShiny, analyses statistiques).

# Tests et Validation

## Stratégie de Test

La validation du code s'appuie sur 12 suites de tests couvrant l'ensemble des fonctionnalités de notre projet. Les tests utilisent le module `Test.jl` de Julia et fixent une seed aléatoire (`Random.seed!(1234)`) pour garantir la reproductibilité.

### Couverture des Tests

**Tests de base** : `compute_damage` (dégâts non-négatifs, type de critique correct), `attaquer` (réduction des PV, respect des bornes).

**Tests de compétences** : Vérification du coût en PM, application correcte des dégâts, spécialisations par rôle (Mage/Fireball, Chevalier/PowerStrike).

**Tests d'effets** : Chaque effet testé individuellement (Poison, Bleed, Regen, Shield, Stun) et en combinaison (stack d'effets multiples).

**Tests de combat** : Déroulement complet, détermination du gagnant, cohérence des logs.

## Exemples de Tests Clés

### Test de Cohérence des Dégâts

```julia
@testset "compute_damage" begin
    dmg, crit = compute_damage(50, 10)
    @test dmg ≥ 0              # Jamais de dégâts négatifs
    @test crit isa Bool        # Type booléen pour le critique
end
```

### Test de Consommation de Ressources

```julia
@testset "use_skill Mage" begin
    mage = Mage()
    target = Chevalier()
    fireball = Fireball(10, 30)
    
    before_PV = target.stats.PV
    before_PM = mage.stats.PM
    
    dmg = use_skill(mage, fireball, target)
    
    @test dmg ≥ 0
    @test target.stats.PV == before_PV - dmg
    @test mage.stats.PM == before_PM - 10    # Coût exact
end
```

### Test de Stack d'Effets

```julia
@testset "Stack d'effets" begin
    c = make_dummy_role(100, effects=[
        Poison(2, 5), 
        Bleed(2, 3),
        Regen(2, 4), 
        Shield(2, 10)
    ])
    
    shield, stunned, regen, dmg = apply_effects_round!(c)
    
    @test shield == 10
    @test regen == 4
    @test dmg == 8              # 5 (poison) + 3 (bleed)
    @test c.stats.PV == 96      # 100 + 4 (regen) - 8 (dmg)
    @test length(c.effects) == 4
end
```

### Test de Combat Complet

```julia
@testset "combat simple" begin
    gandalf = Mage()
    arthur = Chevalier()
    
    winner, logs = combat(gandalf, arthur; max_rounds=10)
    
    @test winner in [gandalf.nom, arthur.nom]
    @test length(logs) ≥ 1              # Au moins un tour
    @test all(log -> log.damage ≥ 0, logs)  # Pas de dégâts négatifs
end
```

## Résultats et Fiabilité

Les 12 suites de tests passent avec succès (100% de réussite), validant la cohérence de nos fonctions, l'application fidèle des effets et la stabilité du moteur de combat. La reproductibilité est garantie par la fixation de la seed aléatoire.

# Simulations et Analyse

## Méthodologie de Simulation

Les simulations sont des exécutions répétées du même combat avec réinitialisation complète entre chaque itération. La fonction `Base.rand` est étendue pour accepter deux personnages et un nombre de simulations.

```julia
function Base.rand(j1::Role, j2::Role; 
                  n_simulations=10, 
                  max_rounds=100,
                  dmg_mat=Dict(), 
                  skill_usage=Dict())
    results = Dict(j1.nom => 0, j2.nom => 0)
    pv_init_j1 = j1.stats.PV
    pv_init_j2 = j2.stats.PV
    
    for i in 1:n_simulations
        # Copies fraîches avec réinitialisation des PV
        fighter1 = deepcopy(j1)
        fighter2 = deepcopy(j2)
        fighter1.stats.PV = pv_init_j1
        fighter2.stats.PV = pv_init_j2
        
        winner, logs = combat(fighter1, fighter2; 
                             max_rounds=max_rounds,
                             dmg_mat=dmg_mat, 
                             skill_usage=skill_usage)
        
        if fighter1.stats.PV > 0
            results[fighter1.nom] += 1
        else
            results[fighter2.nom] += 1
        end
    end
    
    return results
end
```

**Réinitialisation complète** : Utilisation de `deepcopy` pour éviter les effets de bord entre simulations. Les PV sont restaurés explicitement aux valeurs initiales.

**Accumulation de statistiques** : Les dictionnaires `dmg_mat` et `skill_usage` accumulent les données sur l'ensemble des simulations, permettant l'analyse des dégâts moyens par matchup et de la fréquence d'utilisation des compétences.

## Résultats d'Équilibrage

### Analyse des Matchups

**Mage vs Chevalier (100 combats)** :
- Victoires Mage : 72% (haute défense du Chevalier inefficace contre magie)
- Dégâts moyens/tour : Mage 38.5, Chevalier 16.2
- Durée moyenne : 6.3 tours
- Utilisation Fireball : 65% des tours du Mage
- **Conclusion** : Domination magique claire, dégâts qui contournent l'armure

**Archer vs Chevalier (100 combats)** :
- Victoires Archer : 51%, Chevalier : 49%
- Durée moyenne : 8.7 tours
- **Conclusion** : Matchup équilibré, vitesse de l'Archer compense la défense du Chevalier

**Mage vs Archer (100 combats)** :
- Victoires Mage : 68%
- Durée moyenne : 5.2 tours (combats rapides)
- **Conclusion** : Fragilité de l'Archer face aux dégâts magiques explosifs

Le gobelin, également présent est le personnage le plus faible comme mentionné dans la partie "Rôles".

### Impact des Compétences

**Fireball (Mage)** :
- Utilisée dans 65% des tours où PM disponibles
- Dégâts moyens : 42 (vs 26 pour attaque normale)
- Coût : 10 PM (Mage en a 100, permet ~10 utilisations)

**PowerStrike (Chevalier)** :
- Utilisée dans 18% des tours (probabilité 20% ajustée par disponibilité PM)
- Dégâts moyens : 35 (vs 22 pour attaque normale)
- Coût : 8 PM (Chevalier en a 20, utilisation limitée)


# Visualisation et Interface Utilisateur

## Interface RShiny

Une application RShiny interactive permet de contrôler et visualiser des **combats** en temps réel. L'interface communique avec le backend Julia via des appels de fonctions exportées.

**Fonctionnalités** :
- **Sélection des combattants** : L'utilisateur peut choisir 2 personnages qui s'affrontent. L'utilisateur à la possibilité de choisir un rôle et de lui donner un nom.
- **Ajustement des stats** : Modification des PV, ATK, DEFENSE, etc. En cochant la case "Personnaliser les statistiques".
- **Lancement des combats** : Bouton déclenchant les simulations.
- **Affichage des résultats** : Trois onglets disponibles, la partie résumé du combat (détails) ou l'on retrouve le combattant qui attaque, celui qui subit l'attaque (cible), les points de vie de l'attaquant et de la cible, mais aussi l'action (si l'attaque est l'utilisation d'une compétence ou d'une attaque basique). On retrouve aussi l'évolution des points de vieet des dégâts d'attaque au fil des tours (Analyse). Enfin, notre application RShiny nous permet de connaître le vainqueur du combat (Résultat).

**Architecture technique** :
- Backend Julia pour les calculs (performances optimales).
- Frontend RShiny pour l'interface réactive avec l'utilisation du package Rulia pour utiliser nos fonctions du projet codées en Julia.

## Visualisations Bonito

Notre fichier Bonito.md permet également de créer des visualisations interactives mais directement en Julia.

### Graphiques Implémentés

**Résumé des combats** : Nous pouvons visualiser pour n combats qui est le vainqueur.
**Points de vie par round** : Tableau qui résume l'évolution des PV des deux combattants tour par tour.
**Défense par round** : Tableau qui résume l'évolution de la défense des deux combattants tour par tour.
**Graphique des PV par round** : Evolution graphique des points de vie des deux combattants par tour.
**Simulation des PV interactive** : Possibilité d'ajuster les stats des deux combattants, PV, Attaque et Défense, cela modifie le graphique qui représente les points de vie tour par tour. Si par exemple, on augmente fortement les stats d'attaques du combattant 1, le combattant 2 va voir ses points de vie diminuer drastiquement.

# Apprentissage et Évolution

## Progression Pédagogique

### Phase 1 : Fondamentaux

**Concepts maîtrisés** : Syntaxe de base, types primitifs (Int, Float, String), structures mutables vs immutables, fonctions simples, constructeurs, REPL et workflow interactif.

**Réalisations** : Structure `Stats`, rôles basiques sans comportements, premières fonctions de calcul.

**Difficultés rencontrées** : Compréhension de la différence entre `struct` et `mutable struct`, gestion des types dans les fonctions, erreurs de syntaxe fréquentes (`;` optionnels, `end` obligatoires).

### Phase 2 : Construction

**Concepts maîtrisés** : Hiérarchie de types avec `abstract type`, multiple dispatch (signatures de base), distribution de probabilités (`Distributions.jl`), organisation en modules.

**Réalisations** : Système de combat fonctionnel, mécaniques d'attaque avec aléatoire, fonction `compute_damage` complète, premiers tests de combats.

**Difficultés rencontrées** : Compréhension du multiple dispatch, gestion de l'ordre des `include()` dans le module principal.

### Phase 3 : Amélioration technique du projet

**Concepts maîtrisés** : Multiple dispatch avancé (spécialisations multiples), composition d'objets (effets dans vecteurs), tests unitaires avec `Test.jl`, `deepcopy` pour isoler les états, extension de fonctions de `Base`.

**Réalisations** : Système d'effets de statut complet, compétences spécialisées par rôle, moteur de combat avec logs détaillés, tests unitaires exhaustifs.

**Difficultés rencontrées** : Gestion des effets temporaires (décrémentation, suppression), typage flexible des vecteurs d'effets (`Vector{Any}` nécessaire), reproduction des bugs dans les tests (seed aléatoire).

### Phase 4 : Optimisation et Visualisation

**Concepts maîtrisés** : Intégration avec RShiny (implémentation du package Rulia), création de visualisations avec Bonito.

**Réalisations** : Système de simulation complète avec statistiques, interface RShiny interactive, graphiques Bonito variés, rapport complet en Quarto.

**Difficultés rencontrées** : Communication Julia-R, choix des visualisations pertinentes.

## Apports du Cours CQLS

Le cours CQLS ([https://cqls.dyndoc.fr/julia]) a été notre ressource principale d'apprentissage. Voici les concepts directement appliqués de ce cours à notre projet.

### Types et Dispatch

**Du cours** : Explication claire de la hiérarchie de types, distinction `abstract type` vs structures concrètes, principe du multiple dispatch avec exemples progressifs.

**Application** : Architecture complète du projet basée sur cette hiérarchie (`Role`, `StatusEffect`, `Skill`), utilisation intensive du multiple dispatch pour les attaques et compétences, extension de `Base.show()` pour affichage personnalisé des rôles.

### Structures de Données

**Du cours** : Utilisation de `Dict` pour stocker des paires clé-valeur, manipulation de `Vector` et opérations communes, choix entre mutabilité et immutabilité.

**Application** : Dictionnaires `dmg_mat` et `skill_usage` pour accumuler les statistiques, vecteur `effects` pour stocker les effets actifs, vecteur `logs` pour l'historique des actions.

### Écosystème et Packages

**Du cours** : Introduction aux packages standards (`Test`, `Random`), utilisation de `Distributions.jl` pour l'aléatoire avancé, organisation en modules avec `using` et `export`.

**Application** : Module `RPGSimulator` structuré avec exports explicites, utilisation de `Normal(μ, σ)` pour les dégâts, `Random.seed!()` pour la reproductibilité des tests, `Test.@testset` pour l'organisation des tests.

### Bonnes Pratiques

**Du cours** : Constructeurs par défaut avec arguments, documentation avec docstrings, séparation du code en fichiers thématiques.

**Application** : Constructeurs comme `Mage(; nom="Gandalf")`, organisation modulaire en 7 fichiers, développement itératif avec tests intermédiaires dans le REPL.

## Défis Techniques et Solutions

### Gestion de la Mutabilité

**Problème** : Lors des simulations, les modifications sur un personnage affectaient les simulations suivantes.

**Solution** : Utilisation systématique de `deepcopy()` pour créer des copies indépendantes avant chaque combat, réinitialisation explicite des PV aux valeurs initiales.

### Typage Flexible des Effets

**Problème** : Nécessité de stocker différents types d'effets (`Poison`, `Shield`, etc.) dans le même vecteur.

**Solution** : Déclaration `effects::Vector{Any}` permettant le polymorphisme, avec vérification de type via `isa` lors de l'application.

### Organisation Modulaire

**Problème** : Dépendances circulaires entre fichiers, ordre d'inclusion critique.

**Solution** : Hiérarchie claire des `include()` dans `RPGSimulator.jl` : types de base d'abord (`roles.jl`), puis dépendances (`effets.jl`), enfin fonctions de haut niveau (`combat.jl`, `simulation.jl`).

### Reproductibilité des Tests

**Problème** : Tests aléatoires échouant sporadiquement rendant le débogage difficile.

**Solution** : Fixation de la seed avec `Random.seed!(1234)` au début des tests, permettant des exécutions déterministes et reproductibles.

# Perspectives d'Amélioration

## Extensions Fonctionnelles

Nous avons également réfléchi pour développer d'avantage notre projet, en ajoutant des rôles supplémentaires, des compétences supplémentaires, des extensions de combats. Voici des idées d'améliorations:

### Nouveaux Rôles et Compétences

**Voleur** : Rôle orienté vitesse et esquive avec compétence `Backstab` (dégâts accrus si frappe en premier) et `Dodge` (chance d'éviter une attaque).

**Paladin** : Rôle hybride tank/soin avec `HolyStrike` (dégâts + petit soin personnel) et `Blessing` (buff de défense temporaire).

**Assassin** : Haute attaque, PV faibles, compétence `Poison Blade` (applique effet Poison) et `Shadow Step` (double frappe avec pénalité PM)...

### Mécaniques Avancées

**Combats en équipe** : Extension à 3v3 ou 5v5 avec gestion des cibles multiples, compétences de zone, buffs d'équipe et synergie entre rôles.

**Équipement** : Système d'items modifiant les stats (armes augmentent ATK, armures augmentent DEFENSE, accessoires donnent effets passifs).


# Conclusion

## Réalisations

En l'espace de trois mois, notre équipe est passée d'une **connaissance nulle de Julia** à la production d'un projet complet et fonctionnel. Le **RPGSimulator** intègre plus de 1200 lignes de code structuré, 12 suites de tests unitaires avec 100% de réussite, un système d'effets composables, des simulations et des visualisations interactives.

Le projet démontre une maîtrise progressive des concepts fondamentaux (types, fonctions, modules) jusqu'aux techniques avancées (multiple dispatch, tests reproductibles, intégration multi-langage). L'architecture modulaire permet une extension facile : ajout de nouveaux rôles, compétences ou effets sans modifier le code existant.


## Remerciements

Ce projet n'aurait pas été possible sans le **cours CQLS** ([https://cqls.dyndoc.fr/julia]) qui nous a fourni une base solide et des exemples concrets. Les explications progressives et la documentation de référence ont été des ressources importantes pour notre apprentissage autonome.

Nous remercions également la communauté Julia pour l'excellente documentation officielle, les packages de qualité et les forums d'entraide qui ont répondu à nos questions techniques.

Enfin, nous remercions M. Drouilhet pour sa disponibilité constante et son écoute attentive face aux difficultés que nous avons rencontrées.

---

**Équipe RPGSimulator**  
Maxime, Jed, Hussin, Simon  
Septembre - Décembre 2025