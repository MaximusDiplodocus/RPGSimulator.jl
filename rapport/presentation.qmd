---
title: "RPGSimulator"
subtitle: "Notre voyage d'apprentissage en Julia"
author: "Maxime, Jed, Hussin & Simon"
format: 
  revealjs:
    theme: dracula
    css: custom.css
    slide-number: true
    transition: slide
    incremental: false
---

# Le Point de Départ

:::: {.columns}
::: {.column width="50%"}
**Septembre 2025**

- Aucune connaissance de Julia
- Découverte d'un nouveau paradigme
- Objectif ambitieux : créer un simulateur de combat
:::

::: {.column width="50%"}
**Notre guide**

Le cours CQLS nous a accompagnés tout au long du projet

[cqls.dyndoc.fr/julia](https://cqls.dyndoc.fr/julia)
:::
::::

**Le défi** : Transformer une page blanche en un simulateur de combat fonctionnel en 3 mois

# Phase 1 : Les Premiers Pas

**Comprendre les bases**

- Découverte de la syntaxe Julia
- Différence entre `struct` et `mutable struct`
- Création de nos premières structures : `Stats` et `Role`
- Apprentissage du REPL pour tester rapidement

**Première victoire** : Un personnage avec des statistiques qui existent !

**Première difficulté** : Pourquoi mes stats ne changent pas ? → Découverte de la mutabilité


# Phase 2 : Construire les Fondations

**Le système prend forme**

- Introduction aux **types abstraits** pour organiser notre hiérarchie
- Découverte du **multiple dispatch** : un point indispensable
- Création du système d'attaque avec probabilités
- Intégration de `Distributions.jl` pour l'aléatoire

**Moment clé** : Réaliser qu'une fonction peut avoir plusieurs comportements selon les types d'arguments

**Difficulté surmontée** : Gérer l'ordre des `include()` dans notre module


# Phase 3 : Le Multiple Dispatch, notre allié

**La puissance de Julia**

Ce qui a changé notre vision du projet :

- **Une fonction, plusieurs comportements** : `use_skill` s'adapte automatiquement au rôle
- **Extension sans modification** : Ajouter un nouveau personnage n'oblige pas à toucher le code existant
- **Spécialisation intelligente** : Le Mage lance Fireball, le Chevalier utilise PowerStrike


# Phase 4 : Enrichir le Gameplay

**Complexité croissante**

Ajout de profondeur stratégique :

- **Système d'effets composables** : Poison, Shield, Stun, Regen, Bleed
- **Gestion temporelle** : Les effets durent plusieurs tours
- **Combinaisons** : Un personnage peut subir plusieurs effets simultanés

**Apprentissage clé** : `Vector{Any}` pour stocker des types différents dans un même vecteur

**Défi technique** : Décrémenter les durées et retirer les effets expirés proprement


# Phase 5 : Garantir la Qualité

**Tests et validation**

Pourquoi les tests sont devenus essentiels :

- Bugs aléatoires impossibles à reproduire → Solution : `Random.seed!()`
- Modifications qui cassent le code existant → Tests systématiques
- 12 suites de tests couvrant tous les aspects du jeu

**Leçon importante** : Tester tôt évite les erreurs futures

**Satisfaction** : Voir tous les tests validés (100% de réussite)


# Phase 6 : Simulations et Découvertes

**Analyser l'équilibrage**

Ce que les simulations nous ont révélé :

- **Mage trop fort** contre Chevalier plus de 70% de victoires
- **Matchup équilibré** : Archer vs Chevalier, combat rude et équilibré
- **Impact des compétences** : Fireball augmente les dégâts de 62%

**Apprentissage technique** : `deepcopy` pour isoler chaque simulation

**Surprise** : Les résultats contredisent nos intuitions initiales


# Phase 7 : Visualiser pour Comprendre

Deux approches complémentaires :

**RShiny** : Interface interactive pour contrôler les combats

- Choisir les personnages
- Ajuster les statistiques
- Voir l'évolution des PV en temps réel

**Bonito** : Graphiques en pur Julia

- Visualisation directe des combats
- Tableaux round par round
- Simulations interactives

**Défi** : Faire communiquer Julia et R (résolu avec le package Rulia)


# Ce Que Julia Nous a Appris

**Changement de paradigme**

- Le multiple dispatch > POO classique pour notre cas d'usage
- La composition d'objets > l'héritage complexe
- Types abstraits pour structurer sans contraindre

**Bonnes pratiques découvertes**

- Tests dès le début du projet
- Prototypage rapide dans le REPL
- Organisation modulaire en fichiers thématiques
- Documentation indispensable

**Outil préféré** : Le REPL pour tester chaque idée instantanément


# Notre Évolution en Chiffres

**Septembre** : 0 ligne de Julia aucune notion dans ce langage

**Décembre** : 

- 1200+ lignes de code structuré
- 7 fichiers modulaires organisés
- 12 suites de tests (100% de réussite)
- 4 rôles, 5 effets, 2 compétences
- 2 interfaces de visualisation

**Temps total** : 3 mois d'apprentissage intensif


# Et Maintenant ?

**Ce qu'on pourrait ajouter si on continuait**

- Nouveaux rôles : Voleur, Paladin, Assassin
- Combats en équipe (3v3, 5v5)
- Système d'équipement et d'inventaire
- ...

**L'important** : L'architecture permet tout ça sans réécrire l'existant !


# Remerciements

**Le cours CQLS** pour :

- Les explications progressives et claires
- Les exemples concrets et applicables
- La documentation de référence toujours accessible

**M. Drouilhet** pour :

- Sa disponibilité constante
- Son aide face à nos difficultés techniques
- Ses conseils d'organisation

**La communauté Julia** pour son écosystème de qualité


# Conclusion

**Notre voyage en une phrase** :

De la découverte d'un langage inconnu à la maîtrise d'un paradigme puissant, en construisant un projet complet qui fonctionne et qui nous a passionné.

**Ce qui reste** :

- Une nouvelle façon de penser la programmation
- Des outils pour résoudre des problèmes complexes
- La confiance d'apprendre n'importe quel langage

**Et surtout** : Un RPG Simulator dont on est fiers !


# Merci de votre attention !

**Équipe RPGSimulator**  
Maxime, Jed, Hussin, Simon