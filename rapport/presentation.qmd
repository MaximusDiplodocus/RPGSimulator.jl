---
title: "Projet RPGSimulator"
author: 
  - "Maxime, Jed, Hussin et Simon"
  - "√âquipe RPGSimulator"
date: "Septembre √† D√©cembre 2025"
format: 
  revealjs:
    theme: [dracula, custom.scss]
    slide-number: true
    transition: fade
toc: true
---

# üìò Introduction

Ce rapport pr√©sente l'int√©gralit√© de notre projet **RPGSimulator**, r√©alis√© en **Julia**.
Nous avons commenc√© **sans aucune connaissance du langage**, et avons progressivement appris gr√¢ce √† :

* des recherches personnelles,
* des exp√©rimentations successives,
* la documentation Julia,
* **le cours du CQLS** : [https://cqls.dyndoc.fr/julia](https://cqls.dyndoc.fr/julia), qui nous a √©norm√©ment aid√©s.

Nous avons construit un moteur de combat tour par tour, structur√© et modulable, en d√©veloppant progressivement :

* la structure des personnages (r√¥les, stats),
* un syst√®me d‚Äôattaques et de comp√©tences (skills),
* des combats simples puis simul√©s,
* l‚Äôutilisation du **multiple dispatch**, au c≈ìur du design Julia,
* des **tests unitaires**,
* une **visualisation** des combats via **RShiny** et **BonitoBook**.

Ce document est un **rapport complet Quarto**, comprenant notre d√©marche, nos objectifs et le code essentiel.


# üéØ Objectifs du Projet

Nos objectifs √©taient les suivants :

1. **Apprendre Julia depuis z√©ro**, comprendre sa philosophie et ses sp√©cificit√©s (performance, types, multiple dispatch).
2. D√©velopper un **jeu RPG minimaliste** mais complet : r√¥les, attaques, comp√©tences, combats.
3. Structurer le code proprement en **plusieurs fichiers** (modules, fonctions s√©par√©es).
4. Mettre en place un syst√®me efficace utilisant **le multiple dispatch**.
5. Tester et fiabiliser l‚Äôensemble via **tests unitaires**.
6. Simuler des combats nombreux et analyser les r√©sultats.
7. Cr√©er une **visualisation dynamique** des combats via **RShiny** et **BonitoBook**.


# üß± Apprentissage de Julia

Nous avons proc√©d√© par √©tapes :

* apprentissage des types, structs, m√©thodes,
* compr√©hension du syst√®me de dispatch,
* tests simples de fonctions,
* manipulation des dictionnaires, modules, imports.

Nous nous sommes beaucoup appuy√©s sur le cours :
‚û°Ô∏è [https://cqls.dyndoc.fr/julia](https://cqls.dyndoc.fr/julia)


# üß© Construction du Projet

## Fichier : `stats.jl`

```julia
struct Stats
    PV::Int
    PM::Int
    ATK::Int
    DEFENSE::Int
    VITESSE::Int
end
```


## Fichier : `roles.jl`

```julia
abstract type Role end

struct Archer <: Role
    nom::String
    stats::Stats
end

struct Mage <: Role
    nom::String
    stats::Stats
end

struct Chevalier <: Role
    nom::String
    stats::Stats
end

struct Gobelin <: Role
    nom::String
    stats::Stats
end
```


# ‚öîÔ∏è Attaques & Multiple Dispatch

## Fonction de calcul des d√©g√¢ts

```julia
function compute_damage(base_atk, def; sd_frac=0.12, crit_chance=0.10, crit_mult=1.6)
    sd = base_atk * sd_frac
    raw = round(Int, rand(Normal(base_atk, sd)))
    dmg = max(raw - def, 0)
    crit = rand() < crit_chance
    return crit ? (round(Int, dmg * crit_mult), true) : (dmg, false)
end
```


# üî• Comp√©tences Sp√©cialis√©es

## Exemple cl√© : Fireball (Mage ‚Üí Ennemi)

```julia
function use_skill(att::Mage, skl::Fireball, def::Role; dmg_mat=Dict(), skill_usage=Dict())
    if att.stats.PM < skl.cost_pm
        println("$(att.nom) n'a pas assez de PM pour Fireball.")
        return 0
    end

    att.stats.PM -= skl.cost_pm
    effective_def = Int(round(def.stats.DEFENSE * 0.7))

    base_atk = skl.power + Int(round(att.stats.ATK * 0.5))

    dmg, crit = compute_damage(base_atk, effective_def,
        sd_frac=0.05, crit_chance=0.22, crit_mult=2.2)

    def.stats.PV = max(def.stats.PV - dmg, 0)

    println("$(att.nom) lance Fireball sur $(def.nom) => $dmg d√©g√¢ts" * (crit ? " (CRIT!)" : ""))

    skill_usage[string(typeof(skl))] = get(skill_usage,string(typeof(skl)),0) + 1

    return dmg
end
```


# üß™ Tests Unitaires

### Test sur compute_damage

```julia
@testset "Test compute_damage" begin
    dmg, crit = compute_damage(20, 5)
    @test dmg >= 0
end
```

### Test sur Fireball

```julia
@testset "Test Fireball" begin
    m = Mage("Gandalf", Stats(70,100,25,5,10))
    g = Gobelin("Gob", Stats(60,10,12,3,15))
    fire = Fireball(30, 10)
    dmg = use_skill(m, fire, g)
    @test dmg > 0
end
```


# ü§ñ Simulation de Combats

```julia
function simulate_battles(att, def, n)
    results = Int[]
    for i in 1:n
        att_copy = deepcopy(att)
        def_copy = deepcopy(def)
        push!(results, battle(att_copy, def_copy))
    end
    return results
end
```


# üìà Visualisation (RShiny & BonitoBook)

Nous avons repr√©sent√© graphiquement :

* l‚Äô√©volution des PV,
* les d√©g√¢ts par tour,
* les r√©sultats de combats r√©p√©t√©s.

### Export des donn√©es

```julia
open("combat_data.csv", "w") do io
    println(io, "round,pv_att,pv_def,dmg")
    for r in logs
        println(io, "$(r.round),$(r.pv_att),$(r.pv_def),$(r.dmg)")
    end
end
```


# üèÅ Conclusion

En partant **sans aucune notion en Julia**, nous avons r√©ussi √† :

* comprendre les bases du langage,
* √©crire un moteur RPG structur√© et modulaire,
* impl√©menter un syst√®me complet de stats, attaques, comp√©tences,
* exploiter le **multiple dispatch** de mani√®re avanc√©e,
* tester et valider le code,
* simuler de nombreux combats,
* visualiser nos r√©sultats dans RShiny et BonitoBook.

Ce projet fut une excellente introduction au langage Julia et √† la programmation modulaire orient√©e performance.




