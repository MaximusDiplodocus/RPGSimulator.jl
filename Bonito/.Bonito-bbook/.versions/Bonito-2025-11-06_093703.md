# New Book

```julia (editor=true, logging=false, output=true)
using CSV, DataFrames, CairoMakie
using Bonito, Tables
include("../Examples/test.jl")

# --- Création des personnages ---
archer = Archer(nom="Jed")
archer.stats = Stats(PV=100, PM=20, ATK=30, VITESSE=40, DEFENSE=10)

gobelin = Gobelin(nom="Hussin")
gobelin.stats = Stats(PV=120, PM=0, ATK=35, VITESSE=40, DEFENSE=5)

# --- Simulation de 3 combats (sans affichage automatique) ---
res = simulate_many!(archer, gobelin, N=3);

# --- Préparer les DataFrames à afficher ---
summary = res.summary
pv = res.pv_df

# --- Affichage avec Bonito ---
Bonito.DOM.div(
    Bonito.DOM.h2("Résumé des combats"),
    Bonito.Table(summary),
    Bonito.DOM.h2("Points de vie par round"),
    Bonito.Table(pv)
)

```
```julia (editor=true, logging=false, output=true)
using Bonito
using WGLMakie
using Observables

WGLMakie.activate!(; resize_to_body=true)

function interactive_pv_simulation()
    # Observables pour Jed
    pv_jed  = Observable(100)
    atk_jed = Observable(30)
    def_jed = Observable(10)

    # Observables pour Gobelin
    pv_gob  = Observable(120)
    atk_gob = Observable(25)
    def_gob = Observable(5)

    # Observables pour les lignes
    xdata = Observable(Float64[])
    ydata_jed = Observable(Float64[])
    ydata_gob = Observable(Float64[])

    # Figure principale avec un layout en 3 lignes, 1 colonne
    fig = Figure(resolution = (900, 600), layout = GridLayout())
    
    # Graphique (ligne 1)
    ax = Axis(fig[1,1], title="Évolution des PV", xlabel="Round", ylabel="PV")
    
    # Lignes de PV
    line_jed = lines!(ax, xdata, ydata_jed; color=:blue, linewidth=2)
    line_gob = lines!(ax, xdata, ydata_gob; color=:red, linewidth=2)

    # Légende
    Legend(fig[1,2], [line_jed, line_gob], ["Jed (Archer)", "Gobelin"])

    # Fonction PV par round (3 rounds)
    function compute_pv_traj(pv, atk, defn; rounds=3)
        traj = Float64[]
        current = pv
        push!(traj, current)
        for r in 1:rounds
            dmg = max(0, atk - defn)
            current = max(current - dmg, 0)
            push!(traj, current)
        end
        return 0:rounds, traj
    end

    # Mise à jour réactive
    function update_lines!()
        rounds, traj_jed = compute_pv_traj(pv_jed[], atk_gob[], def_jed[], rounds=3)
        _, traj_gob = compute_pv_traj(pv_gob[], atk_jed[], def_gob[], rounds=3)
        xdata[] = collect(rounds)
        ydata_jed[] = traj_jed
        ydata_gob[] = traj_gob
    end

    # SliderGrid pour Jed (ligne 2)
    sg_jed = SliderGrid(
        fig[2,1],
        (label="Jed PV", range=0:500, startvalue=pv_jed[]),
        (label="Jed ATK", range=0:100, startvalue=atk_jed[]),
        (label="Jed DEF", range=0:100, startvalue=def_jed[])
    )
    sPV_jed, sATK_jed, sDEF_jed = sg_jed.sliders
    on(sPV_jed.value)  do v pv_jed[] = v; update_lines!() end
    on(sATK_jed.value) do v atk_jed[] = v; update_lines!() end
    on(sDEF_jed.value) do v def_jed[] = v; update_lines!() end

    # SliderGrid pour Gobelin (ligne 3)
    sg_gob = SliderGrid(
        fig[3,1],
        (label="Gob PV", range=0:500, startvalue=pv_gob[]),
        (label="Gob ATK", range=0:100, startvalue=atk_gob[]),
        (label="Gob DEF", range=0:100, startvalue=def_gob[])
    )
    sPV_gob, sATK_gob, sDEF_gob = sg_gob.sliders
    on(sPV_gob.value)  do v pv_gob[] = v; update_lines!() end
    on(sATK_gob.value) do v atk_gob[] = v; update_lines!() end
    on(sDEF_gob.value) do v def_gob[] = v; update_lines!() end

    # Initialiser le graphique
    update_lines!()

    return Bonito.DOM.div(
        Bonito.DOM.h3("Simulateur : Jed vs Gobelin"),
        fig
    )
end

Bonito.DOM.div(
    Bonito.DOM.h2("Simulation de PV interactive"),
    interactive_pv_simulation()
)

```
```julia (editor=true, logging=false, output=true)
using Bonito
using WGLMakie
using Observables

WGLMakie.activate!(; resize_to_body=true)

function interactive_pv_simulation()
    # Observables pour Jed
    pv_jed  = Observable(100)
    atk_jed = Observable(30)
    def_jed = Observable(10)

    # Observables pour Gobelin
    pv_gob  = Observable(120)
    atk_gob = Observable(25)
    def_gob = Observable(5)

    # Observables pour les lignes
    xdata = Observable(Float64[])
    ydata_jed = Observable(Float64[])
    ydata_gob = Observable(Float64[])

    # Figure principale avec 1 ligne et 2 colonnes
    fig = Figure(resolution=(1000,600), layout=GridLayout())
    
    # Colonne gauche : graphique
    ax = Axis(fig[1,1], title="Évolution des PV", xlabel="Round", ylabel="PV",
              limits=((0,3), (0, max(pv_jed[], pv_gob[])+50)))

    # Lignes de PV avec labels pour la légende
    line_jed = lines!(ax, xdata, ydata_jed; color=:blue, linewidth=2, label="Jed (Archer)")
    line_gob = lines!(ax, xdata, ydata_gob; color=:red, linewidth=2, label="Gobelin")

    # Légende automatique
    axislegend(ax, position=:rt)  # à droite du graphique

    # Colonne droite : sliders (stackés verticalement)
    slider_col = GridLayout()
    fig[1,2] = slider_col  # placer la grille des sliders dans la 2e colonne

    # SliderGrid pour Jed
    sg_jed = SliderGrid(
        slider_col[1,1],
        (label="Jed PV", range=0:500, startvalue=pv_jed[]),
        (label="Jed ATK", range=0:100, startvalue=atk_jed[]),
        (label="Jed DEF", range=0:100, startvalue=def_jed[])
    )
    sPV_jed, sATK_jed, sDEF_jed = sg_jed.sliders

    # SliderGrid pour Gobelin
    sg_gob = SliderGrid(
        slider_col[2,1],
        (label="Gob PV", range=0:500, startvalue=pv_gob[]),
        (label="Gob ATK", range=0:100, startvalue=atk_gob[]),
        (label="Gob DEF", range=0:100, startvalue=def_gob[])
    )
    sPV_gob, sATK_gob, sDEF_gob = sg_gob.sliders

    # Fonction PV par round (3 rounds)
    function compute_pv_traj(pv, atk, defn; rounds=3)
        traj = Float64[]
        current = pv
        push!(traj, current)
        for r in 1:rounds
            dmg = max(0, atk - defn)
            current = max(current - dmg, 0)
            push!(traj, current)
        end
        return 0:rounds, traj
    end

    # Mise à jour réactive
    function update_lines!()
        rounds, traj_jed = compute_pv_traj(pv_jed[], atk_gob[], def_jed[], rounds=3)
        _, traj_gob = compute_pv_traj(pv_gob[], atk_jed[], def_gob[], rounds=3)
        xdata[] = collect(rounds)
        ydata_jed[] = traj_jed
        ydata_gob[] = traj_gob
        # Ajuster limites Y pour dézoom automatique
        new_max = max(max(traj_jed...), max(traj_gob...)) + 20
        ax.limits[] = ((0,3), (0, new_max))
    end

    # Relier sliders aux observables
    on(sPV_jed.value)  do v pv_jed[] = v; update_lines!() end
    on(sATK_jed.value) do v atk_jed[] = v; update_lines!() end
    on(sDEF_jed.value) do v def_jed[] = v; update_lines!() end
    on(sPV_gob.value)  do v pv_gob[] = v; update_lines!() end
    on(sATK_gob.value) do v atk_gob[] = v; update_lines!() end
    on(sDEF_gob.value) do v def_gob[] = v; update_lines!() end

    # Initialiser le graphique
    update_lines!()

    return Bonito.DOM.div(
        Bonito.DOM.h3("Simulateur : Jed vs Gobelin"),
        fig,
        Bonito.DOM.h3("Paramètres Jed"),
        sg_jed,
        Bonito.DOM.h3("Paramètres Gobelin"),
        sg_gob
    )
end

Bonito.DOM.div(
    Bonito.DOM.h2("Simulation de PV interactive"),
    interactive_pv_simulation()
)

```
