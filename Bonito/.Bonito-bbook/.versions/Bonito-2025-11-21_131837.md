# New Book

```julia (editor=true, logging=true, output=true)
using Bonito, DataFrames
using RPGSimulator

# -----------------------------
# Création des personnages
# -----------------------------
archer = Archer(nom="Jed")
archer.stats = Stats(PV=100, PM=20, ATK=30, VITESSE=40, DEFENSE=10)

gobelin = Gobelin(nom="Hussin")
gobelin.stats = Stats(PV=120, PM=0, ATK=35, VITESSE=40, DEFENSE=5)

# -----------------------------
# Simulation des combats
# -----------------------------
n_simulations = 5
winners = String[]

for i in 1:n_simulations
    # Copie indépendante pour chaque simulation
    f1, f2 = deepcopy(archer), deepcopy(gobelin)
    
    # Lancer le combat
    winner, logs = combat(f1, f2; max_rounds=50)
    
    # Enregistrer le vainqueur
    push!(winners, winner)
end

# -----------------------------
# Préparer le résumé
# -----------------------------
summary_df = DataFrame(Simulation=1:n_simulations, Winner=winners)

# -----------------------------
# Affichage avec BonitoBook
# -----------------------------
Bonito.DOM.div(
    Bonito.DOM.h2("Résumé des combats"),
    Bonito.Table(summary_df)
)
```
```julia (editor=true, logging=true, output=true)
using Bonito, DataFrames
using RPGSimulator

# Création des personnages
archer = Archer(nom="Jed")
archer.stats = Stats(PV=100, PM=20, ATK=30, VITESSE=40, DEFENSE=10)

gobelin = Gobelin(nom="Hussin")
gobelin.stats = Stats(PV=120, PM=0, ATK=35, VITESSE=40, DEFENSE=5)

# Lancer un seul combat
f1, f2 = deepcopy(archer), deepcopy(gobelin)
winner, logs = combat(f1, f2; max_rounds=50)

# Préparer les données PV par round
round_numbers = sort(unique([log.round for log in logs]))  # tous les rounds
jed_pv = Int[]
hussin_pv = Int[]

for r in round_numbers
    # PV du dernier log de l'archer pour ce round
    logs_round = [log for log in logs if log.round == r]
    push!(jed_pv, logs_round[end].actor_PV)  # PV après le dernier action de ce round
    push!(hussin_pv, logs_round[end].target_PV)  # PV de l'autre
end

df_pv = DataFrame(
    Round = round_numbers,
    Jed_PV = jed_pv,
    Hussin_PV = hussin_pv
)

# Affichage dans Bonito
Bonito.DOM.div(
    Bonito.DOM.h2("Points de vie par round"),
    Bonito.Table(df_pv)
)

```
```julia (editor=true, logging=true, output=true)
# Simulation / exemple de données DEFENSE par round
defense_data = DataFrame(combat=Int[], round=Int[], actor=String[], defense=Int[])

# Simule données pour 2 personnages sur 5 rounds
for combat_id in 1:3
    for round in 0:5
        push!(defense_data, (combat_id, round, "Jed", max(10, 20 - round)))
        push!(defense_data, (combat_id, round, "Hussin", max(5, 15 - 2*round)))
    end
end

# Affichage avec Bonito
Bonito.DOM.div(
    Bonito.DOM.h2("Défense par round"),
    Bonito.Table(defense_data)
)

```
```julia (editor=true, logging=true, output=true)

```
```julia (editor=true, logging=true, output=true)
using Bonito, WGLMakie
using RPGSimulator

WGLMakie.activate!(; resize_to_body=true)

# -----------------------------
# Création des personnages
# -----------------------------
archer = Archer(nom="Jed")
archer.stats = Stats(PV=100, PM=20, ATK=30, VITESSE=40, DEFENSE=10)

gobelin = Gobelin(nom="Hussin")
gobelin.stats = Stats(PV=120, PM=0, ATK=35, VITESSE=40, DEFENSE=5)

# -----------------------------
# Lancer un combat
# -----------------------------
f1, f2 = deepcopy(archer), deepcopy(gobelin)
winner, logs = combat(f1, f2; max_rounds=50)

# -----------------------------
# Préparer les données PV par round
# -----------------------------
rounds = sort(unique([log.round for log in logs if log.action in ["attack", "skill"]]))
jed_pv = Float64[]
gob_pv = Float64[]

for r in rounds
    logs_round = [log for log in logs if log.round == r]
    
    # PV fin du round pour Jed
    jed_logs = [log.actor_PV for log in logs_round if log.actor == "Jed"]
    jed_end = isempty(jed_logs) ? jed_pv[end] : maximum(jed_logs)  # si vide, reprendre dernier PV
    
    # PV fin du round pour Gobelin
    gob_logs = [log.actor_PV for log in logs_round if log.actor == "Hussin"]
    gob_end = isempty(gob_logs) ? gob_pv[end] : maximum(gob_logs)
    
    push!(jed_pv, jed_end)
    push!(gob_pv, gob_end)
end

# -----------------------------
# Créer le graphique avec Makie
# -----------------------------
fig = Figure(resolution=(900,500))
ax = Axis(fig[1,1], title="Évolution des PV par round", xlabel="Round", ylabel="PV")
lines!(ax, rounds, jed_pv; color=:blue, linewidth=2, label="Jed")
lines!(ax, rounds, gob_pv; color=:red, linewidth=2, label="Gobelin")
axislegend(ax)

# -----------------------------
# Affichage dans BonitoBook
# -----------------------------
Bonito.DOM.div(
    Bonito.DOM.h2("Graphique des PV par round"),
    fig
)

```
```julia (editor=true, logging=false, output=true)
using Bonito
using WGLMakie
using Observables

WGLMakie.activate!(; resize_to_body=true)

function interactive_pv_simulation()
    # Observables pour Jed
    pv_jed  = Observable(100)
    atk_jed = Observable(30)
    def_jed = Observable(10)

    # Observables pour Gobelin
    pv_gob  = Observable(120)
    atk_gob = Observable(25)
    def_gob = Observable(5)

    # Observables pour les lignes
    xdata = Observable(Float64[])
    ydata_jed = Observable(Float64[])
    ydata_gob = Observable(Float64[])

    # Figure principale
    fig = Figure(resolution = (900, 600), layout = GridLayout())
    
    # Graphique (ligne 1)
    ax = Axis(fig[1,1], title="Évolution des PV", xlabel="Round", ylabel="PV",
              limits=((0,3), (0, max(pv_jed[], pv_gob[])+50)))
    
    # Lignes de PV
    line_jed = lines!(ax, xdata, ydata_jed; color=:blue, linewidth=2)
    line_gob = lines!(ax, xdata, ydata_gob; color=:red, linewidth=2)
    
    # Légende
    Legend(fig[1,2], [line_jed, line_gob], ["Jed (Archer)", "Gobelin"])

    # Fonction PV par round (3 rounds)
    function compute_pv_traj(pv, atk, defn; rounds=3)
        traj = Float64[]
        current = pv
        push!(traj, current)
        for r in 1:rounds
            dmg = max(0, atk - defn)
            current = max(current - dmg, 0)
            push!(traj, current)
        end
        return 0:rounds, traj
    end

    # Mise à jour réactive
    function update_lines!()
        rounds, traj_jed = compute_pv_traj(pv_jed[], atk_gob[], def_jed[], rounds=3)
        _, traj_gob = compute_pv_traj(pv_gob[], atk_jed[], def_gob[], rounds=3)
        xdata[] = collect(rounds)
        ydata_jed[] = traj_jed
        ydata_gob[] = traj_gob
        # Ajuster limites Y pour dézoom automatique
        new_max = max(max(traj_jed...), max(traj_gob...)) + 20
        ax.limits[] = ((0,3), (0, new_max))
    end

    # SliderGrid pour Jed (ligne 2)
    sg_jed = SliderGrid(
        fig[2,1],
        (label="Jed PV", range=0:500, startvalue=pv_jed[]),
        (label="Jed ATK", range=0:100, startvalue=atk_jed[]),
        (label="Jed DEF", range=0:100, startvalue=def_jed[])
    )
    sPV_jed, sATK_jed, sDEF_jed = sg_jed.sliders
    on(sPV_jed.value)  do v pv_jed[] = v; update_lines!() end
    on(sATK_jed.value) do v atk_jed[] = v; update_lines!() end
    on(sDEF_jed.value) do v def_jed[] = v; update_lines!() end

    # SliderGrid pour Gobelin (ligne 3)
    sg_gob = SliderGrid(
        fig[3,1],
        (label="Gob PV", range=0:500, startvalue=pv_gob[]),
        (label="Gob ATK", range=0:100, startvalue=atk_gob[]),
        (label="Gob DEF", range=0:100, startvalue=def_gob[])
    )
    sPV_gob, sATK_gob, sDEF_gob = sg_gob.sliders
    on(sPV_gob.value)  do v pv_gob[] = v; update_lines!() end
    on(sATK_gob.value) do v atk_gob[] = v; update_lines!() end
    on(sDEF_gob.value) do v def_gob[] = v; update_lines!() end

    # Initialiser le graphique
    update_lines!()

    return Bonito.DOM.div(
        Bonito.DOM.h3("Simulateur : Jed vs Gobelin"),
        fig,
        Bonito.DOM.h3("Paramètres Jed"),
        sg_jed,
        Bonito.DOM.h3("Paramètres Gobelin"),
        sg_gob
    )
end

Bonito.DOM.div(
    Bonito.DOM.h2("Simulation de PV interactive"),
    interactive_pv_simulation()
)
```
